cd /working/lab_miguelr/badeU/GenSEM_Files/GWASClean/CommonFactorGWAS/Clump_9traits_NeuroInflam_Psych/FINAL
export LC_ALL=C


CATS=(MCP_ONLY_STRICT MCP_NEUROINFLAM_ONLY MCP_PSYCH_ONLY SHARED_ALL3)
WINS=(250000 100000 50000)

# ---------- helper: merge intervals without bedtools ----------
# Input BED-like: chr  start  end  ... (tab-delimited, sorted by chr then start)
# Output: chr  start  end  n_intervals_mergedIntoThis
merge_bed () {
  awk -v OFS="\t" '
  function flush(){ if (NRout>0) print chr, s, e, n }
  BEGIN{ NRout=0 }
  {
    c=$1; a=$2; b=$3
    if (NRout==0){
      chr=c; s=a; e=b; n=1; NRout=1
    } else if (c==chr && a<=e){
      if (b>e) e=b
      n++
    } else {
      print chr, s, e, n
      chr=c; s=a; e=b; n=1
    }
  }
  END{ if (NRout>0) print chr, s, e, n }
  '
}

# ---------- 1) Build merged loci for each window ----------
for WIN in "${WINS[@]}"; do
  echo "===== BUILD loci WIN=${WIN} ====="

  # lead SNP windows BED: chr start end snp p category
  awk -v OFS="\t" -v W="$WIN" '
    NR==1{next}
    {
      chr="chr"$3;
      bp=$4;
      start=bp-W; if (start<0) start=0;
      end=bp+W;
      print chr,start,end,$1,$5,$2
    }' MASTER_PLEIOTROPY_TABLE.tsv > "leads_${WIN}.bed"

  for cat in "${CATS[@]}"; do
    awk -v C="$cat" '$6==C' "leads_${WIN}.bed" \
      | sort -t $'\t' -k1,1 -k2,2n \
      | cut -f1-3 \
      | merge_bed \
      > "${cat}.${WIN}.merged.bed"
  done

  echo "locus counts:"
  for cat in "${CATS[@]}"; do
    printf "%-22s %8d\n" "$cat" "$(wc -l < "${cat}.${WIN}.merged.bed")"
  done
  echo
done

# ---------- 2) Overlap + Jaccard for each window ----------
python3 - <<'PY'
import os

CATS = ["MCP_ONLY_STRICT","MCP_NEUROINFLAM_ONLY","MCP_PSYCH_ONLY","SHARED_ALL3"]
WINS = [250000, 100000, 50000]

def read_bed(path):
    # chr start end n
    out = []
    with open(path) as f:
        for line in f:
            line=line.strip()
            if not line: 
                continue
            parts=line.split("\t")
            out.append((parts[0], int(parts[1]), int(parts[2])))
    return out

def overlaps(A, B):
    # count intervals in A that overlap >=1 interval in B
    i=j=0
    cnt=0
    while i < len(A) and j < len(B):
        ca, sa, ea = A[i]
        cb, sb, eb = B[j]
        if ca < cb:
            i += 1
            continue
        if cb < ca:
            j += 1
            continue
        # same chrom
        if ea <= sb:
            i += 1
        elif eb <= sa:
            j += 1
        else:
            # overlap exists for A[i]
            cnt += 1
            i += 1
    return cnt

def union_len(a, b):
    return len(set(a).union(set(b)))

def jaccard_from_counts(a_len, b_len, a_over_b, b_over_a):
    # This is NOT true Jaccard by bp length; it's Jaccard by "interval identity"
    # Approximate intersection size by symmetric overlap minimum bound:
    inter = min(a_over_b, b_over_a)
    union = a_len + b_len - inter
    return inter, union, (inter/union if union else 0.0)

print("===== LOCUS OVERLAPS (interval counts) =====")
for win in WINS:
    beds = {c: read_bed(f"{c}.{win}.merged.bed") for c in CATS}
    lens = {c: len(beds[c]) for c in CATS}

    print(f"\n--- WIN={win} ---")
    # directional overlaps
    print("A_overlaps_B\tA\tB\tcount\tA_total\tpct_A")
    for A in CATS:
        for B in CATS:
            if A==B: 
                continue
            c = overlaps(beds[A], beds[B])
            pct = (100.0*c/lens[A]) if lens[A] else 0.0
            print(f"A_overlaps_B\t{A}\t{B}\t{c}\t{lens[A]}\t{pct:.2f}")

    # symmetric summary + "interval-Jaccard"
    print("\nA\tB\tA_total\tB_total\tA∩B(min)\tA∪B\tJaccard_interval")
    for i in range(len(CATS)):
        for j in range(i+1, len(CATS)):
            A=CATS[i]; B=CATS[j]
            a_over = overlaps(beds[A], beds[B])
            b_over = overlaps(beds[B], beds[A])
            inter, union, jac = jaccard_from_counts(lens[A], lens[B], a_over, b_over)
            print(f"{A}\t{B}\t{lens[A]}\t{lens[B]}\t{inter}\t{union}\t{jac:.4f}")

print("\nNOTE: 'Jaccard_interval' is based on merged-interval counts (not bp-length).")
print("If you want basepair-length Jaccard, we can compute that too without bedtools.")
PY
